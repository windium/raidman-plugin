<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raidman Terminal</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #terminal {
            height: 100%;
            width: 100%;
        }

        /* Inline xterm.css styles as fallback/replacement */
        .xterm {
            cursor: text;
            position: relative;
            user-select: none;
            -ms-user-select: none;
            -webkit-user-select: none;
        }

        .xterm.focus,
        .xterm:focus {
            outline: none;
        }

        .xterm .xterm-helpers {
            position: absolute;
            z-index: 5;
        }

        .xterm .xterm-helper-textarea {
            position: absolute;
            opacity: 0;
            z-index: -5;
            width: 0;
            height: 0;
            white-space: nowrap;
            overflow: hidden;
            resize: none;
        }

        .xterm .composition-view {
            background: #000;
            color: #FFF;
            display: none;
            position: absolute;
            white-space: nowrap;
            z-index: 1;
        }

        .xterm .composition-view.active {
            display: block;
        }

        .xterm .xterm-viewport {
            background-color: #000;
            overflow-y: scroll;
            cursor: default;
            position: absolute;
            right: 0;
            left: 0;
            top: 0;
            bottom: 0;
        }

        .xterm .xterm-screen {
            position: relative;
        }

        .xterm .xterm-screen canvas {
            position: absolute;
            left: 0;
            top: 0;
        }

        .xterm .xterm-scroll-area {
            visibility: hidden;
        }

        .xterm-char-measure-element {
            display: inline-block;
            visibility: hidden;
            position: absolute;
            left: -9999em;
            top: 0;
        }

        .xterm.enable-mouse-events {
            cursor: default;
        }

        .xterm.xterm-cursor-pointer,
        .xterm .xterm-cursor-pointer {
            cursor: pointer;
        }

        .xterm.column-select.focus {
            cursor: crosshair;
        }

        .xterm .xterm-accessibility,
        .xterm .xterm-message {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            z-index: 10;
            color: transparent;
        }

        .xterm .live-region {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        .xterm-dim {
            opacity: 0.5;
        }

        .xterm-underline {
            text-decoration: underline;
        }

        .xterm-strikethrough {
            text-decoration: line-through;
        }
    </style>
</head>

<body>
    <div id="terminal"></div>

    <script src="unraidterm.js"></script>

    <script>
        // Parse Query Params
        const urlParams = new URLSearchParams(window.location.search);
        const apiKey = urlParams.get('x-api-key');
        const type = urlParams.get('type') || 'docker';
        const container = urlParams.get('container') || '';
        const vm = urlParams.get('vm') || '';

        if (!apiKey) {
            document.body.innerHTML = '<h1 style="color:white;text-align:center">Error: Missing API Key</h1>';
            throw new Error("Missing API Key");
        }

        // Initialize Terminal
        // Assuming unraidterm.js exposes 'Terminal' globally just like stock xterm.js
        // If not, we might need to inspect the object.
        const term = new Terminal({
            theme: {
                background: '#000000',
                foreground: '#ffffff',
                cursor: '#f15a24'
            },
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace'
        });

        // Addons - assuming they are included in unraidterm.js and attached or available globally?
        // If unraidterm.js is a bundle, it might auto-register addons or provide them.
        // For now, let's assume standard 'FitAddon' and 'AttachAddon' are NOT globally available unless exported.
        // Since the user provided a bundled file, it's safer to rely on 'term' first.

        // However, if the bundle includes them, we might access them differently.
        // Let's try standard access logic.

        try {
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => fitAddon.fit());
        } catch (e) {
            console.warn("FitAddon not found, fallback to basic open");
            term.open(document.getElementById('terminal'));
        }

        // WebSocket Connection
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/raidman/connect?x-api-key=${encodeURIComponent(apiKey)}&type=${encodeURIComponent(type)}&container=${encodeURIComponent(container)}&vm=${encodeURIComponent(vm)}`;

        const socket = new WebSocket(wsUrl);

        socket.onopen = () => {
            // Try using AttachAddon if available, otherwise manual
            try {
                const attachAddon = new AttachAddon.AttachAddon(socket);
                term.loadAddon(attachAddon);
            } catch (e) {
                console.log("AttachAddon not found, using manual socket handling");
                // Manual fallback
                term.onData(data => socket.send(data));
                socket.onmessage = event => term.write(event.data);
            }
            term.focus();
        };

        socket.onerror = (error) => {
            console.error('WebSocket Error:', error);
            term.write('\r\n\x1b[31mConnection Error\x1b[0m\r\n');
        };

        socket.onclose = () => {
            term.write('\r\n\x1b[33mConnection Closed\x1b[0m\r\n');
        };
    </script>
</body>

</html>